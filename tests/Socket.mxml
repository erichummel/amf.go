<?xml version="1.0" encoding="utf-8"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute"
    width="360" height="700">
  <mx:Script>
    <![CDATA[

        import flash.net.Socket;

        import TestClasses.EmptyDynamicClass;
        import TestClasses.MixedDynamicClass;
        import TestClasses.SealedClass;

        var socket:flash.net.Socket
        var expectingLength:Boolean
        var dataLength:int = 0

        /*
        public dynamic class EmptyDynamicClass
        {
        }

        public dynamic class MixedDynamicClass
        {
            var i:int = 123
            var s:string = "apple"
        }
        */

        public function connect():void {
            socket = new flash.net.Socket();
            expectingLength = true
            result_text.text = "Connecting..\n"

            socket.addEventListener(ProgressEvent.SOCKET_DATA, onData)
            socket.addEventListener(Event.CONNECT, onConnect)
            socket.connect("127.0.0.1", 8080)
        }

        public function onConnect(event:Event):void {

            // Write a bunch of different objects, to test unpacking.
            socket.writeUTF("String:")
            socket.writeObject("a string")

            socket.writeUTF("True:")
            socket.writeObject(true)

            socket.writeUTF("False:")
            socket.writeObject(false)

            socket.writeUTF("Null:")
            socket.writeObject(null)
            
            socket.writeUTF("Undefined:")
            socket.writeObject(undefined)

            socket.writeUTF("Integer 0:")
            socket.writeObject(0)

            socket.writeUTF("Integer 1:")
            socket.writeObject(1)

            socket.writeUTF("Integer 1234:")
            socket.writeObject(1234)

            socket.writeUTF("Integer 123456789:")
            socket.writeObject(123456789)

            socket.writeUTF("Float 0.123:")
            socket.writeObject(0.123)

            socket.writeUTF("Array [1,2,3]:")
            socket.writeObject([1, 2, 3])

            socket.writeUTF("Array [1,2,3]:")
            socket.writeObject([1, 2, 3])

            socket.writeUTF("Mixed array [a: apple, b: banana]:")
            var mixedArray:Array = new Array()
            mixedArray["a"] = "apple"
            mixedArray["b"] = "banana"
            socket.writeObject(mixedArray)

            socket.writeUTF("Mixed array 2 [1,2,3, a: apple, b: banana]:")
            var mixedArray2:Array = new Array(1,2,3)
            mixedArray2["a"] = "apple"
            mixedArray2["b"] = "banana"
            socket.writeObject(mixedArray2)

            socket.writeUTF("Dictionary:")
            socket.writeObject({ firstName: "John", lastName: "Smith" })

            socket.writeUTF("Empty dynamic object:")
            socket.writeObject(new TestClasses.EmptyDynamicClass())

            socket.writeUTF("Populated dynamic object:")
            var dynObj = new TestClasses.EmptyDynamicClass()
            dynObj.x = "banana"
            dynObj.y = new Array(1,2,3)
            socket.writeObject(dynObj)

            socket.writeUTF("Dynamic class with static fields:")
            socket.writeObject(new TestClasses.MixedDynamicClass())

            socket.writeUTF("Dynamic class with dynamic and static fields:")
            var dynObj2 = new TestClasses.MixedDynamicClass()
            dynObj2.m = 1.2345
            dynObj2.n = 12345678
            socket.writeObject(dynObj2)

            socket.writeUTF("Sealed class:")
            socket.writeObject(new TestClasses.SealedClass())

            // Write some messages that will hopefully be sent as references.
            socket.writeUTF("Array with the same object 3 times")
            socket.writeObject(new Array(dynObj, dynObj, dynObj))

            var cactus:String = "cactus"
            socket.writeUTF("Same string 3 times")
            socket.writeObject(new Array(cactus, cactus, cactus))

            socket.writeUTF("Mixed strings and objects")
            socket.writeObject(new Array(cactus, dynObj, cactus, dynObj, cactus, dynObj))

            // Send an empty label to tell tcp_listener that we're finished.
            socket.writeUTF("")

            socket.flush()

            result_text.text += "Sent test data\n"
        }


        public function onData(event:ProgressEvent):void {
            if (expectingLength) {
                if (socket.bytesAvailable < 4) {
                    return
                }
                dataLength = socket.readInt()
                expectingLength = false
                result_text.text += "Expecting " + dataLength + " bytes\n"
            }

            if (socket.bytesAvailable < dataLength) {
                result_text.text += "Not enough bytes, " + socket.bytesAvailable + " available\n"
                return
            }
            result_text.text += "Proceeding, there are " + socket.bytesAvailable + " available\n"

            while (true) {
                var label = socket.readUTF()
                if (label == "") {
                    result_text.text += "Found empty label"
                    break
                }

                var obj = socket.readObject()
                var objStr = "";
                if (obj == null)
                    objStr = "null"
                else
                    objStr = obj.toString()

                result_text.text += label + " " + objStr + "\n"
            }

            socket.close()
            socket = null
        }
    ]]>

</mx:Script>
<mx:Button x="250" y="10" label="connect" click="connect();"/>
<mx:TextArea x="10" y="36" width="319" height="600" id="result_text"/>
<mx:Label x="10" y="10" text="Result:"/>
</mx:Application>
